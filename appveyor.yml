# Build and check LDGLite x86 and x86_64 architectures unsing Qt/MinGW platform
version: 'LDGLite-AV-{build}'

clone_folder: c:\projects\ldglite
# skip automatic cloning because we want restore cached items in the clone directory first
clone_script: echo skip

# we're caching qt5 for MinGW x86_64 and the LDraw library
cache:
 - 'C:\projects\$(ldgl_librepo)'
 - '$(APPVEYOR_BUILD_FOLDER)\LDraw'

branches:
  only:
   - master

platform: x64

configuration: release

matrix:
  fast_finish: true

# we're building both x86 and x86_64 target architectures
# we must also setup the x86_64 Qt5 build environment for MinGW
# the matrix block below must always play the x86_64 build last
# in order to preserve the artifact pakcaging logic described later
environment:
  ldgl_build: appveyor_ci
  ldgl_job2arch: x86_64
  ldgl_distdir: lpub3d_windows_3rdparty
  ldgl_distdirpath: $(APPVEYOR_BUILD_FOLDER)\$(ldgl_distdir)
  ldgl_job1package: LDGLite-Job1-AV-$(APPVEYOR_BUILD_NUMBER)
  ldgl_qtlibs: mingw-w64-x86_64-qt5-5.9.1-1-any.pkg.tar.xz
  ldgl_iculibs: mingw-w64-x86_64-icu-58.2-2-any.pkg.tar.xz
  ldgl_librepo: lpub3d_mingw-x86_64_libs
  ldgl_librepodir: /c/projects/$(ldgl_librepo)
  matrix:
  - ldgl_target_arch: x86
  - ldgl_target_arch: x86_64

# generte remote-desktop credentials - useful for debugging
# clear the cache if specified
# set the make parameters and qt library path
# process [build pkg] commit message request
# process [deploy pkg] commit message request
init:
 - ps: write-host "Building $env:ldgl_target_arch architecture..."
 - ps: iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))
 - ps: |
      If ($env:APPVEYOR_REPO_COMMIT_MESSAGE.ToLower().Contains("[clear avcache]"))
      {
        write-host "[clear avcache] detected."

        $apiUrl = 'https://ci.appveyor.com/api'
        $token = 'h2o1p08rkt8jgen5f0ke'
        $headers = @{
          "Authorization" = "Bearer $token"
          "Content-type" = "application/json"
        }

        $accountName = $env:APPVEYOR_ACCOUNT_NAME
        $projectSlug = $env:APPVEYOR_PROJECT_SLUG

        $env:APPVEYOR_CACHE_SKIP_RESTORE  = "true"
        Invoke-RestMethod -Uri "$apiUrl/projects/$accountName/$projectSlug/buildcache" -Headers $headers -Method DELETE
        $env:APPVEYOR_CACHE_SKIP_SAVE = "true"

        Write-Output "Build cache cleared."
      }
 - ps: |
      $env:ldgl_qtpath = "C:\Qt\5.9.1\mingw53_32\bin;C:\Qt\Tools\mingw530_32\bin"
      $env:ldgl_makeargs = "CONFIG+=3RD_PARTY_INSTALL=$env:ldgl_distdir CONFIG+=release CONFIG+=BUILD_CHECK"
      If ($env:ldgl_target_arch -eq "x86_64") {
        $env:ldgl_qtpath = "C:\msys64\MINGW64\bin;C:\msys64\usr\bin"
      }
 - ps: |
      If ($env:APPVEYOR_REPO_COMMIT_MESSAGE.ToLower().Contains("[build pkg]")) {
        write-host "[build pkg] detected."
        $env:LP3D_BUILD_PKG = "yes"
        If ($env:ldgl_target_arch -eq $env:ldgl_job2arch) {
          $env:ldgl_restore_job1_artefact = $true
          $env:ldgl_archive_job2_artefact = $true
        } else {
          $env:ldgl_archive_job1_artefact = $true
        }
      }
 - ps: |
      If ($env:APPVEYOR_REPO_COMMIT_MESSAGE.ToLower().Contains("[deploy pkg]")) {
        write-host "[deploy pkg] detected."
        If ($env:ldgl_target_arch -eq $env:ldgl_job2arch) {
          $env:ldgl_deploy_pkg = $true
        }
      }
 - cmd: SET PATH=%ldgl_qtpath%;%PATH% &echo PATH prepended with %ldgl_qtpath%
 #- ps: Get-ChildItem Env:APPVEYOR* | Sort-Object name
 - ps: Get-ChildItem Env:ldgl_* | Sort-Object name

# This is where we install Qt5 for x86_64 builds along with ICU v58. The source for these items are cached but if not then they are
# downloded. After building out the dev env, we proceed to fetch the commit that fired off the AppVeyor build.
# We don't use git clone because the 'clone_directory' is not empty (restored cached components were added in previous steps) - so the
# git clone command will fail. Instead we use fetch and checkout to pretty much replicate the same behaviour as the default git clone.
# This includes setting the clone depth, and fetching the last commit and previous tags
install:
 - cmd: git init %APPVEYOR_BUILD_FOLDER%
 - cmd: cd %APPVEYOR_BUILD_FOLDER%
 - cmd: git remote add origin https://github.com/%APPVEYOR_REPO_NAME%.git
 - cmd: git fetch -qfup --depth=200 origin +%APPVEYOR_REPO_BRANCH% +refs/tags/*:refs/tags/*
 - cmd: git checkout -qf %APPVEYOR_REPO_COMMIT%
 - cmd: bash -lc "if ! test -d ${ldgl_librepodir}; then curl -sL -o ${ldgl_librepo}.tar.gz https://github.com/trevorsandy/${ldgl_librepo}/archive/master.tar.gz; fi"
 - cmd: bash -lc "if ! test -d ${ldgl_librepodir}; then mkdir -p ${ldgl_librepodir} && tar -xzf ${ldgl_librepo}.tar.gz -C ${ldgl_librepodir} --strip-components=1; fi"
 - cmd: bash -lc "if ! test -d ${ldgl_librepodir}; then echo repository ${ldgl_librepodir} not found; else echo library repository available at ${ldgl_librepodir}; fi"
 - cmd: if %ldgl_target_arch%==x86_64 bash -lc "cd ${ldgl_librepodir}/qt-5.9.1-1-release; pacman -U --needed --noconfirm ${ldgl_qtlibs} ${ldgl_iculibs}"

# Download the LDraw parts library for testing if not available from the cache
# The second script in this block is a work-around to combine both the x86 and x86_64 build targets
# into a single artifact. this script is only run on the 2nd of the two jobs (job2).
before_build:
 - ps: cmd.exe /c "%APPVEYOR_BUILD_FOLDER%\tests\getLDrawLib.bat"
 - ps: if (Test-Path "$env:APPVEYOR_BUILD_FOLDER\LDraw\parts") {$env:LDRAWDIR = "$env:APPVEYOR_BUILD_FOLDER\LDraw"}
 - ps: |
      If ($env:ldgl_restore_job1_artefact -eq $true)
      {
        Write-Output "Restoring $env:ldgl_distdirpath build folder from artifact..."

        $apiUrl = 'https://ci.appveyor.com/api'
        $token = 'h2o1p08rkt8jgen5f0ke'
        $headers = @{
          "Authorization" = "Bearer $token"
          "Content-type" = "application/json"
        }

        $accountName = $env:APPVEYOR_ACCOUNT_NAME
        $projectSlug = $env:APPVEYOR_PROJECT_SLUG

        # using clone folder
        $downloadLocation = $env:APPVEYOR_BUILD_FOLDER
        Write-Output "Var downloadLocation     = $downloadLocation"

        # get project with last build details
        $project = Invoke-RestMethod -Method Get -Uri "$apiUrl/projects/$accountName/$projectSlug" -Headers $headers

        # get this job id
        $jobId = $project.build.jobs[0].jobId

        # get job artifacts
        $artifacts = Invoke-RestMethod -Method Get -Uri "$apiUrl/buildjobs/$jobId/artifacts" -Headers $headers

        # $artifactFileName = 'MyWebApp.zip'
        $artifactFileName = $artifacts[0].fileName
        Write-Output "Var artifactFileName     = $artifactFileName"

        # artifact will be downloaded as
        $localArtifactArchive = "$downloadLocation\$artifactFileName"
        Write-Output "Var localArtifactArchive = $localArtifactArchive"

        # download artifact
        Invoke-RestMethod -Method Get -Uri "$apiUrl/buildjobs/$jobId/artifacts/$artifactFileName" `
        -OutFile $localArtifactArchive -Headers @{ "Authorization" = "Bearer $token" }

        # extract artifact
        if (-not (Test-Path $localArtifactArchive)) {
          Write-Output "Error artifact $localArtifactArchive not found"
        } else {
          Write-Output "Extracting artifact $localArtifactArchive ..."
          & 7z.exe x $localArtifactArchive "-o$downloadLocation" | Select-String -Pattern '(^Extracting)|(^Everything)' -CaseSensitive
          $CheckArtifactDir = $downloadLocation+"\builds\windows\"+$env:Configuration
          & Write-Output "Var CheckArtifactDir     = $CheckArtifactDir"
          if (-not (Test-Path $CheckArtifactDir)) {
            Write-Output "Error expanding $localArtifactArchive, $CheckArtifactDir not found"
          } else {
            Write-Output "Build folder $env:ldgl_distdirpath artifact restored"
          }
        }
      }

# regular make stuff here.
build_script:
 - cmd: qmake -v
 - cmd: qmake %ldgl_makeargs%
 - cmd: mingw32-make
 - cmd: mingw32-make install

# Push job1 output to archive for job2 consumption
# Vars used to construct artifacts
# Push job2 artefacts to archive repository and setup for deployment
after_build:
 - ps: $env:LDV_ARTEFACT_ITEM_COUNT = (Get-ChildItem -Path $env:ldgl_distdirpath -Recurse).count
 - ps: write-host "`n  Artifact count....[$env:LDV_ARTEFACT_ITEM_COUNT]"
 - ps: If ($env:ldgl_archive_job1_artefact -eq $true) {7z a -tzip $env:ldgl_job1package $env:ldgl_distdirpath | Select-String -Pattern '(^Creating)|(^Everything)' -CaseSensitive; Push-AppveyorArtifact $env:ldgl_job1package}
 - ps: |
      If (($env:ldgl_archive_job2_artefact -eq $true) -and ([int]$env:LDV_ARTEFACT_ITEM_COUNT -gt 5)){
        cd $env:APPVEYOR_BUILD_FOLDER; write-host "Creating zip archive artefact from ./$env:ldgl_distdir..."
        7z a -tzip $env:ldgl_distdir $env:ldgl_distdir | Select-String -Pattern '(^Creating)|(^Everything)' -CaseSensitive; write-host "Archive $env:ldgl_distdir.zip created."
        $root = Resolve-Path $env:APPVEYOR_BUILD_FOLDER; [IO.Directory]::GetFiles($root.Path, '*.zip', 'TopDirectoryOnly') | % { Push-AppveyorArtifact $_ -Type zip -FileName $_.Substring($root.Path.Length + 1) -DeploymentName $env:ldgl_distdir}
      }

# for the moment we only deploy to github. I'll setup a sourceforge deployment scheme
# at some point going forward
deploy:
 - provider: GitHub
   repository: trevorsandy/ldglite
   description: 'LDGLite - Windows archive package of LPub3D image renderer'
   auth_token:
     secure: rnf4qpF81ISjm8q13OgkAaoKZReXpjODhU9fbGFMhMydHrda1ezLubGXRU9OKGu4
   release: $(ldgl_distdir)
   artifact: $(ldgl_distdir).zip
   prerelease: true
   force_update: true
   on:
    branch: master
    ldgl_deploy_pkg: true
